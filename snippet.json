{
    "snp UnionFind": {
        "prefix": "UnionFind",
        "body": [
            "struct UnionFind",
            "{",
            "  vector<int> par;",
            "",
            "  UnionFind(int N) : par(N)",
            "  {",
            "    for (int i = 0; i < N; i++)",
            "      par[i] = -1;",
            "  }",
            "",
            "  int root(int x)",
            "  {",
            "    if (par[x] < 0)",
            "      return x;",
            "    return par[x] = root(par[x]);",
            "  }",
            "",
            "  void unite(int x, int y)",
            "  {",
            "    int rx = root(x);",
            "    int ry = root(y);",
            "    if (same(x, y))",
            "    {",
            "      return;",
            "    }",
            "    if (par[rx] > par[ry])",
            "      swap(rx, ry);",
            "    par[rx] += par[ry];",
            "    par[ry] = rx;",
            "    return;",
            "  }",
            "",
            "  bool same(int x, int y)",
            "  {",
            "    int rx = root(x);",
            "    int ry = root(y);",
            "    return rx == ry;",
            "  }",
            "",
            "  int size(int x) { return -par[root(x)]; }",
            "};"
        ],
        "description": "UnionFind"
    },
    "snp top_sort": {
        "prefix": "top_sort",
        "body": [
            "bool top_sort(int n, vector<vector<int>> to)",
            "{",
            "  vector<int> graph(n + 1);",
            "  rep1(i, n)",
            "  {",
            "    for (int next : to[i])",
            "    {",
            "      graph[next]++;",
            "    }",
            "  }",
            "  stack<int> st;",
            "  rep1(i, n)",
            "  {",
            "    if (graph[i] == 0)",
            "    {",
            "      st.push(i);",
            "    }",
            "  }",
            "  while (st.size() > 0)",
            "  {",
            "    int now = st.top();",
            "    st.pop();",
            "    for (int next : to[now])",
            "    {",
            "      graph[next]--;",
            "      if (graph[next] == 0)",
            "      {",
            "        st.push(next);",
            "      }",
            "    }",
            "  }",
            "  rep1(i, n)",
            "  {",
            "    if (graph[i] > 0)",
            "    {",
            "      return false;",
            "    }",
            "  }",
            "  return true;",
            "}"
        ],
        "description": "top_sort"
    },
    "snp print_to": {
        "prefix": "print_to",
        "body": [
            "template <typename T>",
            "void print_to(vector<vector<T>> to)",
            "{",
            "  int n = to.size();",
            "  rep(i, n)",
            "  {",
            "    cout << \"from \" << i << \" : to \";",
            "    for (int next : to[i])",
            "    {",
            "      cout << next << \",\";",
            "    }",
            "    cout << endl;",
            "  }",
            "}"
        ],
        "description": "print_to"
    },
    "print_maze": {
        "prefix": "print_maze",
        "body": [
            "void print_maze(vector<vector<char>> maze)",
            "{",
            "  int n = maze.size();",
            "  int m = maze[0].size();",
            "  rep(i, n)",
            "  {",
            "    rep(j, m) { cout << maze[i][j]; }",
            "    cout << endl;",
            "  }",
            "}"
        ],
        "description": "print_maze"
    },
    "snp include": {
        "prefix": "include",
        "body": [
            "#include <algorithm>",
            "#include <iostream>",
            "#include <iomanip>",
            "#include <limits.h>",
            "#include <map>",
            "#include <math.h>",
            "#include <numeric>",
            "#include <queue>",
            "#include <set>",
            "#include <sstream>",
            "#include <string>",
            "#include <utility>",
            "#include <vector>",
            "#include <stack>",
            "",
            "using namespace std;",
            "#define rep(i, n) for (int i = 0; i < n; i++)",
            "#define rep1(i, n) for (int i = 1; i < n + 1; i++)",
            "#define all(A) A.begin(), A.end()",
            "#define itr(A, l, r) A.begin() + l, A.begin() + r",
            "#define debug(var) cout << #var << \" = \" << var << endl;",
            "typedef long long ll;",
            "",
            "int main(void)"
        ],
        "description": "include"
    },
    "snp divisor": {
        "prefix": "divisor",
        "body": [
            "vector<ll> divisor(ll n)",
            "{",
            "  vector<ll> ans;",
            "  for (ll i = 1; i * i <= n; i++)",
            "  {",
            "    if (n % i == 0)",
            "    {",
            "      ans.push_back(i);",
            "      if (i * i != n)",
            "      {",
            "        ans.push_back(n / i);",
            "      }",
            "    }",
            "  }",
            "  sort(all(ans));",
            "  return ans;",
            "}"
        ],
        "description": "divisor"
    },
    "snp yesno": {
        "prefix": "yesno",
        "body": [
            "void yesno(bool b)",
            "{",
            "  if (b)",
            "  {",
            "    cout << \"Yes\" << endl;",
            "  }",
            "  else",
            "  {",
            "    cout << \"No\" << endl;",
            "  }",
            "}",
            ""
        ],
        "description": "yesno"
    },
    "snp_gcd": {
        "prefix": "gcd",
        "body": [
            "ll gcd(ll a, ll b)",
            "{",
            "    if (b == 0)",
            "        return a;",
            "    return gcd(b, a % b);",
            "}",
            ""
        ],
        "description": "snp_gcd"
    },
    "snp minpq": {
        "prefix": "minpq",
        "body": [
            "priority_queue<int,vector<int>, greater<int>>"
        ],
        "description": "minpq"
    },
    "snp dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "template <typename T>",
            "vector<T> dijkstra(int n, vector<vector<pair<int, T>>> to, int start)",
            "{",
            "  vector<T> dist(n + 1, inf);",
            "  priority_queue<pair<int, T>, vector<pair<int, T>>, greater<pair<int, T>>> pq;",
            "  dist[start] = 0;",
            "  pq.push({0, start});",
            "  while (pq.size() > 0)",
            "  {",
            "    auto now_pair = pq.top();",
            "    pq.pop();",
            "    int now = now_pair.second;",
            "    int now_dist = now_pair.first;",
            "    if (dist[now] < now_dist)",
            "    {",
            "      continue;",
            "    }",
            "    for (auto next_pair : to[now])",
            "    {",
            "      int next = next_pair.first;",
            "      T cost = next_pair.second;",
            "      if (dist[now] + cost >= dist[next])",
            "      {",
            "        continue;",
            "      }",
            "      dist[next] = dist[now] + cost;",
            "      pq.push({dist[next], next});",
            "    }",
            "  }",
            "  return dist;",
            "}"
        ],
        "description": "dijkstra"
    },
    "snp bfs": {
        "prefix": "bfs",
        "body": [
            "vector<int> bfs(int n, vector<vector<int>> to, int start)",
            "{",
            "  vector<int> dist(n + 1, inf);",
            "  queue<int> q;",
            "  dist[start] = 0;",
            "  q.push(start);",
            "  while (q.size() > 0)",
            "  {",
            "    int now = q.front();",
            "    q.pop();",
            "    for (int next : to[now])",
            "    {",
            "      if (dist[next] <= dist[now] + 1)",
            "      {",
            "        continue;",
            "      }",
            "      dist[next] = dist[now] + 1;",
            "      q.push(next);",
            "    }",
            "  }",
            "  return dist;",
            "}"
        ],
        "description": "bfs"
    },
    "snp_print_vector": {
        "prefix": "print_vector",
        "body": [
            "auto print_vector = [](auto v)",
            "{",
            "    for (auto i : v)",
            "    {",
            "        cout << i << ',';",
            "    }",
            "    cout << endl;",
            "};"
        ],
        "description": "snp_print_vector"
    },
    "snp_print_vector_vector": {
        "prefix": "print_vector_vector",
        "body": [
            "auto print_vector_vector = [](auto vv)",
            "{",
            "  for (auto v : vv)",
            "  {",
            "    for (auto i : v)",
            "    {",
            "      cout << i << ',';",
            "    }",
            "    cout << endl;",
            "  }",
            "};"
        ],
        "description": "snp_print_vector_vector"
    },
    "snp_pint": {
        "prefix": "pint",
        "body": [
            "pair<int,int>"
        ],
        "description": "snp_pint"
    },
    "snp_print_front": {
        "prefix": "print_front",
        "body": [
            "auto print_front = [](auto q)",
            "{",
            "    while (q.size() > 0)",
            "    {",
            "        cout << q.front() << ',';",
            "        q.pop();",
            "    }",
            "    cout << endl;",
            "};"
        ],
        "description": "snp_print_front"
    },
    "snp_chmin": {
        "prefix": "chmin",
        "body": [
            "auto chmin = [](auto &a, auto b)",
            "{ a = min(a, b); };"
        ],
        "description": "snp_chmin"
    },
    "snp_chmax": {
        "prefix": "chmax",
        "body": [
            "auto chmax = [](auto &a, auto b)",
            "{ a = max(a, b); };"
        ],
        "description": "snp_chmax"
    }
}