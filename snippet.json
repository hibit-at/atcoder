{
    "snp UnionFind": {
        "prefix": "UnionFind",
        "body": [
            "struct UnionFind",
            "{",
            "  vector<int> par;",
            "",
            "  UnionFind(int N) : par(N)",
            "  {",
            "    for (int i = 0; i < N; i++)",
            "      par[i] = -1;",
            "  }",
            "",
            "  int root(int x)",
            "  {",
            "    if (par[x] < 0)",
            "      return x;",
            "    return par[x] = root(par[x]);",
            "  }",
            "",
            "  void unite(int x, int y)",
            "  {",
            "    int rx = root(x);",
            "    int ry = root(y);",
            "    if (same(x, y))",
            "    {",
            "      return;",
            "    }",
            "    if (par[rx] > par[ry])",
            "      swap(rx, ry);",
            "    par[rx] += par[ry];",
            "    par[ry] = rx;",
            "    return;",
            "  }",
            "",
            "  bool same(int x, int y)",
            "  {",
            "    int rx = root(x);",
            "    int ry = root(y);",
            "    return rx == ry;",
            "  }",
            "",
            "  int size(int x) { return -par[root(x)]; }",
            "};"
        ],
        "description": "UnionFind"
    },
    "snp top_sort": {
        "prefix": "top_sort",
        "body": [
            "bool top_sort(int n, vector<vector<int>> to)",
            "{",
            "  vector<int> graph(n + 1);",
            "  rep1(i, n)",
            "  {",
            "    for (int next : to[i])",
            "    {",
            "      graph[next]++;",
            "    }",
            "  }",
            "  stack<int> st;",
            "  rep1(i, n)",
            "  {",
            "    if (graph[i] == 0)",
            "    {",
            "      st.push(i);",
            "    }",
            "  }",
            "  while (st.size() > 0)",
            "  {",
            "    int now = st.top();",
            "    st.pop();",
            "    for (int next : to[now])",
            "    {",
            "      graph[next]--;",
            "      if (graph[next] == 0)",
            "      {",
            "        st.push(next);",
            "      }",
            "    }",
            "  }",
            "  rep1(i, n)",
            "  {",
            "    if (graph[i] > 0)",
            "    {",
            "      return false;",
            "    }",
            "  }",
            "  return true;",
            "}"
        ],
        "description": "top_sort"
    },
    "snp print_to": {
        "prefix": "print_to",
        "body": [
            "template <typename T>",
            "void print_to(vector<vector<T>> to)",
            "{",
            "  int n = to.size();",
            "  rep(i, n)",
            "  {",
            "    cout << \"from \" << i << \" : to \";",
            "    for (int next : to[i])",
            "    {",
            "      cout << next << \",\";",
            "    }",
            "    cout << endl;",
            "  }",
            "}"
        ],
        "description": "print_to"
    },
    "snp_print_maze": {
        "prefix": "print_maze",
        "body": [
            "auto print_maze = [](auto maze)",
            "{",
            "    int n = maze.size();",
            "    int m = maze[0].size();",
            "    rep(i, n)",
            "    {",
            "        rep(j, m) { cout << maze[i][j]; }",
            "        cout << endl;",
            "    }",
            "};"
        ],
        "description": "snp_print_maze"
    },
    "snp_include": {
        "prefix": "include",
        "body": [
            "#include <algorithm>",
            "#include <iostream>",
            "#include <iomanip>",
            "#include <limits.h>",
            "#include <map>",
            "#include <math.h>",
            "#include <numeric>",
            "#include <queue>",
            "#include <set>",
            "#include <sstream>",
            "#include <string>",
            "#include <utility>",
            "#include <vector>",
            "#include <stack>",
            "",
            "using namespace std;",
            "#define rep(i, n) for (int i = 0; i < n; i++)",
            "#define rep1(i, n) for (int i = 1; i < n + 1; i++)",
            "#define all(A) A.begin(), A.end()",
            "#define itr(A, l, r) A.begin() + l, A.begin() + r",
            "#define debug(var) cout << #var << \" = \" << var << endl;",
            "typedef long long ll;",
            "",
            "template< typename T >",
            "istream &operator>>(istream &is, vector< T > &v) {",
            "    for(T &in : v) is >> in;",
            "    return is;",
            "}",
            "",
            "int main(void)"
        ],
        "description": "snp_include"
    },
    "snp divisor": {
        "prefix": "divisor",
        "body": [
            "vector<ll> divisor(ll n)",
            "{",
            "  vector<ll> ans;",
            "  for (ll i = 1; i * i <= n; i++)",
            "  {",
            "    if (n % i == 0)",
            "    {",
            "      ans.push_back(i);",
            "      if (i * i != n)",
            "      {",
            "        ans.push_back(n / i);",
            "      }",
            "    }",
            "  }",
            "  sort(all(ans));",
            "  return ans;",
            "}"
        ],
        "description": "divisor"
    },
    "snp yesno": {
        "prefix": "yesno",
        "body": [
            "void yesno(bool b)",
            "{",
            "  if (b)",
            "  {",
            "    cout << \"Yes\" << endl;",
            "  }",
            "  else",
            "  {",
            "    cout << \"No\" << endl;",
            "  }",
            "}",
            ""
        ],
        "description": "yesno"
    },
    "snp_gcd": {
        "prefix": "gcd",
        "body": [
            "ll gcd(ll a, ll b)",
            "{",
            "    if (b == 0)",
            "        return a;",
            "    return gcd(b, a % b);",
            "}",
            ""
        ],
        "description": "snp_gcd"
    },
    "snp minpq": {
        "prefix": "minpq",
        "body": [
            "priority_queue<int,vector<int>, greater<int>>"
        ],
        "description": "minpq"
    },
    "snp_dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "struct Edge {",
            "    long long to;",
            "    long long cost;",
            "};",
            "using Graph = vector<vector<Edge>>;",
            "using P = pair<long, int>;",
            "const long long INF = 1LL << 60;",
            "void dijkstra(const Graph &G, int s, vector<long long> &dis) {",
            "    int N = G.size();",
            "    dis.resize(N, INF);",
            "    priority_queue<P, vector<P>, greater<P>> pq;  // 「仮の最短距離, 頂点」が小さい順に並ぶ",
            "    dis[s] = 0;",
            "    pq.emplace(dis[s], s);",
            "    while (!pq.empty()) {",
            "        P p = pq.top();",
            "        pq.pop();",
            "        int v = p.second;",
            "        if (dis[v] < p.first) {  // 最短距離で無ければ無視",
            "            continue;",
            "        }",
            "        for (auto &e : G[v]) {",
            "            if (dis[e.to] > dis[v] + e.cost) {  // 最短距離候補なら priority_queue に追加",
            "                dis[e.to] = dis[v] + e.cost;",
            "                pq.emplace(dis[e.to], e.to);",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": "snp_dijkstra"
    },
    "snp bfs": {
        "prefix": "bfs",
        "body": [
            "vector<int> bfs(int n, vector<vector<int>> to, int start)",
            "{",
            "  vector<int> dist(n + 1, inf);",
            "  queue<int> q;",
            "  dist[start] = 0;",
            "  q.push(start);",
            "  while (q.size() > 0)",
            "  {",
            "    int now = q.front();",
            "    q.pop();",
            "    for (int next : to[now])",
            "    {",
            "      if (dist[next] <= dist[now] + 1)",
            "      {",
            "        continue;",
            "      }",
            "      dist[next] = dist[now] + 1;",
            "      q.push(next);",
            "    }",
            "  }",
            "  return dist;",
            "}"
        ],
        "description": "bfs"
    },
    "snp_print_vector": {
        "prefix": "print_vector",
        "body": [
            "auto print_vector = [](auto v)",
            "{",
            "    for (auto i : v)",
            "    {",
            "        cout << i << ',';",
            "    }",
            "    cout << endl;",
            "};"
        ],
        "description": "snp_print_vector"
    },
    "snp_print_vector_vector": {
        "prefix": "print_vector_vector",
        "body": [
            "auto print_vector_vector = [](auto vv)",
            "{",
            "    for (auto v : vv)",
            "    {",
            "        for (auto i : v)",
            "        {",
            "            cout << i << ',';",
            "        }",
            "        cout << endl;",
            "    }",
            "};"
        ],
        "description": "snp_print_vector_vector"
    },
    "snp_pint": {
        "prefix": "pint",
        "body": [
            "pair<int,int>"
        ],
        "description": "snp_pint"
    },
    "snp_print_front": {
        "prefix": "print_front",
        "body": [
            "auto print_front = [](auto q)",
            "{",
            "    while (q.size() > 0)",
            "    {",
            "        cout << q.front() << ',';",
            "        q.pop();",
            "    }",
            "    cout << endl;",
            "};"
        ],
        "description": "snp_print_front"
    },
    "snp_chmin": {
        "prefix": "chmin",
        "body": [
            "auto chmin = [](auto &a, auto b)",
            "{ a = min(a, b); };"
        ],
        "description": "snp_chmin"
    },
    "snp_chmax": {
        "prefix": "chmax",
        "body": [
            "auto chmax = [](auto &a, auto b)",
            "{ a = max(a, b); };"
        ],
        "description": "snp_chmax"
    },
    "snp_print_join": {
        "prefix": "print_join",
        "body": [
            "auto print_join = [](auto v)",
            "{",
            "    int size = v.size();",
            "    rep(i, size)",
            "    {",
            "        if (i < size - 1)",
            "        {",
            "            cout << v[i] << ' ';",
            "        }",
            "        else",
            "        {",
            "            cout << v[i] << endl;",
            "        }",
            "    }",
            "};"
        ],
        "description": "snp_print_join"
    },
    "snp_print_top": {
        "prefix": "print_top",
        "body": [
            "auto print_top = [](auto q)",
            "{",
            "    while (q.size() > 0)",
            "    {",
            "        cout << q.top() << ',';",
            "        q.pop();",
            "    }",
            "    cout << endl;",
            "};"
        ],
        "description": "snp_print_top"
    },
    "snp_print_vector_pair": {
        "prefix": "print_vector_pair",
        "body": [
            "auto print_vector_pair = [](auto v)",
            "{",
            "    for (auto i : v)",
            "    {",
            "        cout << \"(\" << i.first << \",\" << i.second << \")\"",
            "                << \" \";",
            "    }",
            "    cout << endl;",
            "};"
        ],
        "description": "snp_print_vector_pair"
    },
    "snp_print_map": {
        "prefix": "print_map",
        "body": [
            "auto print_map = [](auto mp)",
            "{",
            "    for (auto p : mp)",
            "    {",
            "        cout << \"key : \" << p.first << \", value : \" << p.second << endl;",
            "    }",
            "};"
        ],
        "description": "snp_print_map"
    },
    "snp_vint": {
        "prefix": "vint",
        "body": [
            "vector<int>"
        ],
        "description": "snp_vi"
    },
    "snp_zaz": {
        "prefix": "zaz",
        "body": [
            "auto zaz = [](auto a)",
            "{",
            "    auto b = a;",
            "    sort(all(b));",
            "    b.erase(unique(all(b)), b.end());",
            "    vector<int> ans;",
            "    for (auto i : a)",
            "    {",
            "        auto where = lower_bound(all(b), i);",
            "        ans.push_back(where - b.begin());",
            "    }",
            "    return ans;",
            "};"
        ],
        "description": "snp_zaz"
    },
    "snp_pll": {
        "prefix": "pll",
        "body": [
            "pair<ll,ll>"
        ],
        "description": "snp_pll"
    },
    "snp_print_pair": {
        "prefix": "print_pair",
        "body": [
            "auto print_pair = [](auto p)",
            "{",
            "    cout << '(' << p.first << ',' << p.second << ')';",
            "};"
        ],
        "description": "snp_print_pair"
    },
    "snp_print_lines": {
        "prefix": "print_lines",
        "body": [
            "auto print_lines = [](auto v)",
            "{",
            "    for (auto i : v)",
            "    {",
            "        cout << i << endl;",
            "    }",
            "};"
        ],
        "description": "snp_print_lines"
    },
    "snp_modint": {
        "prefix": "modint",
        "body": [
            "#include <atcoder/modint>",
            "using namespace atcoder;"
        ],
        "description": "snp_modint"
    },
    "snp_comb": {
        "prefix": "comb",
        "body": [
            "vector<mint> factor(1e6 + 1, 1);",
            "rep(i, 1e6)",
            "{",
            "    factor[i + 1] = factor[i] * (i + 1);",
            "}",
            "auto comb = [&](int n, int r)",
            "{",
            "    return factor[n] / factor[n - r] / factor[r];",
            "};"
        ],
        "description": "snp_comb"
    }
}